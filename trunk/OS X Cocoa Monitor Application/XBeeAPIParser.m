////  XBeeAPIParser.m//  PropStream////  Created by Jay Kickliter on 3/2/09.//  Copyright 2009 KarmaLabs. All rights reserved.//#import "XBeeAPIParser.h"@implementation XBeeAPIParser@synthesize delegate;- (id)init{  bufferIndex = 0;    return self;}- (void)setDelegate:(id)newDelegate{  id old = nil;  if (newDelegate != delegate) {    old = delegate;    delegate = [newDelegate retain];    [old release];    delegateAcceptsParsedXbeePackets = [delegate respondsToSelector:@selector(xbeePacketReceived:)];  }}- (void)addData:(NSData *)data{  int i;  int length = [data length];  //NSLog(@"Just added data: %@", data);  [data getBytes:incomingBuffer];  for (i=0; i<length; i++) {    if (incomingBuffer[i] == XBeeDelimiterCharacter) {  // 3/24/09 Just discovered an error here, a packet will sit in the buffer until another one comes in. This isn't a problem if you're receiving the smae data at a fast clip, but if you're receiving packets just occasionally, it is a problem. I was wondering why my received loopback tests where coming in one ID number behind the last sent ID      [self parsePacket:buffer length:bufferIndex];           bufferIndex = 0;    }    else {      buffer[bufferIndex++] = incomingBuffer[i];    }  }}- (void)parsePacket:(unsigned char *)packet length:(int)length{  NSData *packetData;  unsigned char packetBytes[150], checkSum, options, firstCharacterValue;  unsigned int i, packetLength, dataLength, networkAddress, packetDataLength;  unsigned long upperAddress, lowerAddress;   packetLength = 0;  checkSum = 0;  for (i=0; i<length; i++) {    if (packet[i] == XBeeEscapeCharacter) {      packetBytes[packetLength] = packet[i+1]^0x20;      packetLength++;      i++;    } else {      packetBytes[packetLength] = packet[i];      packetLength++;    }  }  for (i=2; i<packetLength; i++) {    checkSum += packetBytes[i];  }  if (checkSum == XBeeChecksumValue) {    dataLength = packetBytes[0] << 8 | packetBytes[1];    NSDictionary *packetDictionary;    switch (packetBytes[2]) {      case XBeeReceivePacketFrame: //A received packet from another XBee        firstCharacterValue = packetBytes[14];        upperAddress = packetBytes[3] << 24 | packetBytes[4] << 16 | packetBytes[5] << 8 | packetBytes[6];        lowerAddress = packetBytes[7] << 24 | packetBytes[8] << 16 | packetBytes[9] << 8 | packetBytes[10];        networkAddress = packetBytes[11] << 8 | packetBytes[12];        options = packetBytes[13];        packetDataLength = packetLength-15;        packetData = [NSData dataWithBytes:&packetBytes[14] length:packetDataLength];        packetDictionary = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithUnsignedLong:upperAddress], @"addressUpper32Bits", [NSNumber numberWithUnsignedLong:lowerAddress], @"addressLower32Bits", [NSNumber numberWithUnsignedLong:networkAddress], @"networkAddress", [NSNumber numberWithUnsignedChar:options], @"options", packetData, @"data", [NSNumber numberWithUnsignedChar:XBeeReceivePacketFrame], @"frameId", [NSNumber numberWithUnsignedChar:firstCharacterValue], @"firstDataByte", [NSNumber numberWithUnsignedInt:packetDataLength], @"dataLength", nil];        if (delegateAcceptsParsedXbeePackets) {          [delegate xbeePacketReceived:packetDictionary];        }        break;    }  } else {    NSLog(@"Received packet failed checksum");  }}- (NSData *)formXbeePacketFromBytes:(unsigned char *)bytes length:(unsigned int)length{  unsigned char bytesToSend[200];  unsigned char escapedBytesToSend[200];  unsigned char checksum = 0;  unsigned int i;  unsigned int ii;  unsigned int escapedLength;  escapedLength = length + 4; // add 4 bytes to the length to compensate for delim char, 2 length bytes, and checksum byte  bytesToSend[0] = length >> 8;  bytesToSend[1] = length;  memcpy(&bytesToSend[2], bytes, length);  for (i=2; i < length + 2; i++) {    checksum += bytesToSend[i];  }  checksum = 0xFF - checksum;  bytesToSend[i] = checksum;  unsigned char temp = 0;  for (i=2; i<length + 3; i++) {    temp += bytesToSend[i];  }  escapedBytesToSend[0] = XBeeDelimiterCharacter;  ii = 1;  for (i=0; i < length + 3; i++) {    if (bytesToSend[i] == 0x7E || bytesToSend[i] == 0x7D || bytesToSend[i] == 0x11 || bytesToSend[i] == 0x13) {      escapedBytesToSend[ii++] = 0x7D;      escapedBytesToSend[ii++] = bytesToSend[i] ^ 0x20;      escapedLength++; //every time a char is escaped, the length of the packed needs to be incremented, to compensate for the extra 0x7D    }    else {      escapedBytesToSend[ii++] = bytesToSend[i];    }  }  return [NSData dataWithBytes:escapedBytesToSend length:escapedLength];}- (NSData *)xbeeApiPacketWithData:(NSData *)data upper32AddressBits:(unsigned long)upper32 lower32AddressBits:(unsigned long)lower32 networkAddress:(unsigned int)netAddress frameId:(unsigned char)frameId{  unsigned char tempBuffer[200];  unsigned int index = 0;  tempBuffer[index++] = XBeeTransmitRequestFrame;  tempBuffer[index++] = frameId;  tempBuffer[index++] = upper32 >> 24;  tempBuffer[index++] = upper32 >> 16;  tempBuffer[index++] = upper32 >> 8;  tempBuffer[index++] = upper32;  tempBuffer[index++] = lower32 >> 24;  tempBuffer[index++] = lower32 >> 16;  tempBuffer[index++] = lower32 >> 8;  tempBuffer[index++] = lower32;  tempBuffer[index++] = netAddress >> 8;  tempBuffer[index++] = netAddress;  tempBuffer[index++] = 0x00; //Radius ?  tempBuffer[index++] = 0x00; //Options ?  [data getBytes:&tempBuffer[index]];  index += [data length];  return [self formXbeePacketFromBytes:tempBuffer length:index];}@end